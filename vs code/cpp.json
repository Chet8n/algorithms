{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Competitive Programming Template": {
		"prefix": "_xxdefault",
		"body": [
			"/**",
			" *    author:  Chet8n",
			" *    created: ${CURRENT_DATE}.${CURRENT_MONTH}.${CURRENT_YEAR} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
			"**/",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"typedef long long int ll;",
			"typedef pair<int, int> pi;",
			"#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)",
			"#define all(x) (x).begin(), (x).end()",
			"#define endl \"\\n\"",
			"#define pb push_back",
			"#define F first",
			"#define S second",
			"#define yes cout << \"YES\" << endl",
			"#define no cout << \"NO\" << endl",
			"#define setbits(x) __builtin_popcountll(x)",
			"template <typename T> T ceil(T a, T b) { return (a + b - 1) / b; }",
			"",
			"const int mod = 1e9 + 7;",
			"const int inf = 2e9 + 5;",
			"const long long infl = 2e18 + 5;",
			"double PI = 3.14159265358979323846;",
			"",
			"#ifdef LOCAL",
			"#include \"algo/debug.h\"",
			"#else",
			"#define db(...) 20",
			"#endif",
			"",
			"void solve() {",
			"    $0",
			"}",
			"",
			"int32_t main() {",
			"    fastio;",
			"    int testCases = 1;",
			"    // cin >> testCases;",
			"    for (int i = 1; i <= testCases; i++) {",
			"        solve();",
			"    }",
			"}"
		],
		"description": "Competitive Programming Template for C++"
	},
	"Default Template": {
		"prefix": "_default",
		"body": [
			"/**",
			" *    author:  Chet8n",
			" *    created: ${CURRENT_DATE}.${CURRENT_MONTH}.${CURRENT_YEAR} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
			"**/",
			"",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)",
			"#define all(x) (x).begin(), (x).end()",
			"#define endl \"\\n\"",
			"#define yes cout << \"YES\" << endl",
			"#define no cout << \"NO\" << endl",
			"#define setbits(x) __builtin_popcountll(x)",
			"template <typename T1, typename T2> auto ceil(T1 a, T2 b) {",
			"    return (static_cast<long long>(a) + static_cast<long long>(b) - 1) / b;",
			"}",
			"",
			"const int mod = 1e9 + 7;",
			"const int inf = 2e9 + 5;",
			"const long long infl = 2e18 + 5;",
			"double PI = 3.14159265358979323846;",
			"",
			"#ifdef LOCAL",
			"#include \"algo/debug.h\"",
			"#else",
			"#define db(...) 20",
			"#endif",
			"",
			"#define int long long",
			"void solve() {",
			"    $0",
			"}",
			"",
			"int32_t main() {",
			"    fastio;",
			"    int testCases = 1;",
			"    // cin >> testCases;",
			"    for (int i = 1; i <= testCases; i++) {",
			"        solve();",
			"    }",
			"}"
		],
		"description": "Default Template"
	},
	"leetcode template": {
		"prefix": "_leetcode",
		"body": [
			"/**",
			" *    author:  Chet8n",
			" *    created: ${CURRENT_DATE}.${CURRENT_MONTH}.${CURRENT_YEAR} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
			" **/",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define fastio ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)",
			"#define all(x) (x).begin(), (x).end()",
			"#define ceill(x, y) ((x + y - 1) / y)",
			"#define setbits(x) __builtin_popcountll(x)",
			"",
			"const int mod = 1e9 + 7;",
			"const int inf = 2e9 + 5;",
			"const long long infl = 2e18 + 5;",
			"double PI = 3.14159265358979323846;",
			"",
			"#ifdef LOCAL",
			"#include \"algo/debug.h\"",
			"#else",
			"#define db(...) 20",
			"#define sout(...) 20",
			"#endif",
			"",
			"class Solution {",
			"  public:",
			"    int solve() { $0return 1; }",
			"};",
			"",
			"#ifdef LOCAL",
			"int32_t main() {",
			"    fastio;",
			"    int testCases = 1;",
			"    // cin >> testCases;",
			"    for (int i = 1; i <= testCases; i++) {",
			"        Solution s;",
			"        auto ans = s.solve();",
			"        sout(ans);",
			"    }",
			"}",
			"#endif"
		],
		"description": "leetcode template"
	},
	"Left and Right function": {
		"prefix": "_leftAndRight",
		"body": [
			"template <typename F>",
			"vector<int> left(const vector<int> &a, F &&f) {",
			"    int n = (int)a.size();",
			"    vector<int> st, l(n, -1);",
			"    for (int i = 0; i < n; i++) {",
			"        while (!st.empty() && !f(a[st.back()], a[i])) {",
			"            st.pop_back();",
			"        }",
			"        if (!st.empty()) {",
			"            l[i] = st.back();",
			"        }",
			"        st.push_back(i);",
			"    }",
			"    return l;",
			"}",
			"",
			"template <typename F>",
			"vector<int> right(const vector<int> &a, F &&f) {",
			"    int n = (int)a.size();",
			"    vector<int> st, r(n, -1);",
			"    for (int i = n - 1; i >= 0; i--) {",
			"        while (!st.empty() && !f(a[st.back()], a[i])) {",
			"            st.pop_back();",
			"        }",
			"        if (!st.empty()) {",
			"            r[i] = st.back();",
			"        }",
			"        st.push_back(i);",
			"    }",
			"    return r;",
			"}",
			"",
			"/**",
			"usage :",
			"    auto leftSmaller = left(a, [](int x, int y) {",
			"        return x < y;",
			"    });",
			"",
			"    auto rightSmaller = right(a, [](int x, int y) {",
			"        return x < y;",
			"    });",
			"**/"
		],
		"description": "gives immediate left and right value of given function"
	},
	"4 Direction": {
		"prefix": "_directions4",
		"body": [
			"int dx[] = {0, 0, 1, -1};",
			"int dy[] = {1, -1, 0, 0};"
		],
		"description": "4 Direction"
	},
	"8 Direction": {
		"prefix": "_directions8",
		"body": [
			"int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};",
			"int dy[] = {1, 1, 0, -1, -1, -1, 0, 1};"
		],
		"description": "8 Direction"
	},
	"zFunctionf for String pattern matching": {
		"prefix": "_zFunction",
		"body": [
			"vector<int> zFunction(string &s) {",
			"    int n = (int)s.length();",
			"    vector<int> z(n);",
			"    for (int i = 1, L = 0, R = 0; i < n; i++) {",
			"        if (i <= R) {",
			"            z[i] = min(z[i - L], R - i + 1);",
			"        }",
			"        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
			"            z[i]++;",
			"        }",
			"        if (i + z[i] - 1 > R) {",
			"            L = i;",
			"            R = i + z[i] - 1;",
			"        }",
			"    }",
			"    z[0] = n;",
			"    return z;",
			"}"
		],
		"description": "zFunctionf for String pattern matching"
	},
	"prefix Function generator": {
		"prefix": "_prefixFunction",
		"body": [
			"vector<int> prefixFunction(string &s) {",
			"    int n = s.length();",
			"    vector<int> lps(n);",
			"",
			"    for (int i = 1; i < n; i++) {",
			"        int j = lps[i - 1];",
			"        while (j > 0 && s[i] != s[j]) {",
			"            j = lps[j - 1];",
			"        }",
			"        if (s[i] == s[j]) {",
			"            j++;",
			"        }",
			"        lps[i] = j;",
			"    }",
			"    return lps;",
			"}"
		],
		"description": "prefix Function generator"
	},
	"Segment Tree with Lazy Propogation": {
		"prefix": "_segmentTreeLazy",
		"body": [
			"template <typename T>",
			"class SegmentTree {",
			"  private:",
			"    int n;",
			"    vector<bool> isLazy;",
			"    vector<T> tree, lazy;",
			"    function<T(T, T)> func;",
			"    T identity;",
			"    T updateIdentity;",
			"",
			"    void mergeNodes(T &curNode, T &leftNode, T &rightNode) {",
			"        curNode = func(leftNode, rightNode);",
			"    }",
			"",
			"    void build(const vector<T> &input, int node, int start, int end) {",
			"        if (start == end) {",
			"            tree[node] = input[start];",
			"            return;",
			"        }",
			"        int mid = (start + end) >> 1;",
			"        build(input, 2 * node, start, mid);",
			"        build(input, 2 * node + 1, mid + 1, end);",
			"        mergeNodes(tree[node], tree[2 * node], tree[2 * node + 1]);",
			"    }",
			"",
			"    void propogate(int node, int start, int end) {",
			"        if (isLazy[node]) {",
			"            tree[node] += (end - start + 1) * lazy[node];",
			"            if (start != end) {",
			"                isLazy[2 * node] = true;",
			"                lazy[2 * node] += lazy[node];",
			"                isLazy[2 * node + 1] = true;",
			"                lazy[2 * node + 1] += lazy[node];",
			"            }",
			"            isLazy[node] = false;",
			"            lazy[node] = updateIdentity;",
			"        }",
			"    }",
			"",
			"    void update(int node, int start, int end, int updateStartIdx, int updateEndIdx, T val) {",
			"        propogate(node, start, end);",
			"",
			"        // no overlap",
			"        if (updateEndIdx < start || updateStartIdx > end) {",
			"            return;",
			"        }",
			"        // total overlap",
			"        if (start >= updateStartIdx && end <= updateEndIdx) {",
			"            isLazy[node] = true;",
			"            lazy[node] = val;",
			"            propogate(node, start, end);",
			"            return;",
			"        }",
			"        // partial overlap",
			"        int mid = (start + end) >> 1;",
			"        update(2 * node, start, mid, updateStartIdx, updateEndIdx, val);",
			"        update(2 * node + 1, mid + 1, end, updateStartIdx, updateEndIdx, val);",
			"        mergeNodes(tree[node], tree[2 * node], tree[2 * node + 1]);",
			"    }",
			"",
			"    T query(int node, int start, int end, int queryStartIdx, int queryEndIdx) {",
			"        propogate(node, start, end);",
			"        // no overlap",
			"        if (queryEndIdx < start || queryStartIdx > end) {",
			"            return identity;",
			"        }",
			"        // total overlap",
			"        if (start >= queryStartIdx && end <= queryEndIdx) {",
			"            return tree[node];",
			"        }",
			"        // partial overlap",
			"        int mid = (start + end) >> 1;",
			"        T leftQuery = query(2 * node, start, mid, queryStartIdx, queryEndIdx);",
			"        T rightQuery = query(2 * node + 1, mid + 1, end, queryStartIdx, queryEndIdx);",
			"        T ans;",
			"        mergeNodes(ans, leftQuery, rightQuery);",
			"        return ans;",
			"    }",
			"",
			"  public:",
			"    vector<T> getTree() {",
			"        return tree;",
			"    }",
			"",
			"    SegmentTree(const vector<T> &input, function<T(T, T)> f, T id = 0, T updateId = 0)",
			"        : func(f), identity(id), updateIdentity(updateId) {",
			"        n = (int)input.size();",
			"        tree.resize(4 * n, identity);",
			"        lazy.resize(4 * n, updateIdentity);",
			"        isLazy.resize(4 * n, false);",
			"        build(input, 1, 0, n - 1);",
			"    }",
			"",
			"    void pointUpdate(int idx, T val) {",
			"        update(1, 0, n - 1, idx, idx, val);",
			"    }",
			"",
			"    void rangeUpdate(int startIdx, int endIdx, T val) {",
			"        update(1, 0, n - 1, startIdx, endIdx, val);",
			"    }",
			"",
			"    T rangeQuery(int startIdx, int endIdx) {",
			"        return query(1, 0, n - 1, startIdx, endIdx);",
			"    }",
			"};",
			""
		],
		"description": "Segment Tree with Lazy Propogation"
	},
	"segment tree": {
		"prefix": "_segmentTree",
		"body": [
			"template <typename T>",
			"class SegmentTree {",
			"  private:",
			"    int n;",
			"    vector<T> tree;",
			"    function<T(T, T)> func;",
			"    T identity;",
			"",
			"    void mergeNodes(T &curNode, T &leftNode, T &rightNode) {",
			"        curNode = func(leftNode, rightNode);",
			"    }",
			"",
			"    void build(const vector<T> &input, int node, int start, int end) {",
			"        if (start == end) {",
			"            tree[node] = input[start];",
			"            return;",
			"        }",
			"        int mid = (start + end) >> 1;",
			"        build(input, 2 * node, start, mid);",
			"        build(input, 2 * node + 1, mid + 1, end);",
			"        mergeNodes(tree[node], tree[2 * node], tree[2 * node + 1]);",
			"    }",
			"",
			"    void pointApply(int node, T val) {",
			"        tree[node] += val;",
			"    }",
			"",
			"    void pointUpdate(int node, int start, int end, int updateIdx, T val) {",
			"",
			"        // no overlap",
			"        if (updateIdx < start || updateIdx > end) {",
			"            return;",
			"        }",
			"        // total overlap",
			"        if (start == end && start == updateIdx) {",
			"            pointApply(node, val);",
			"            return;",
			"        }",
			"        // partial overlap",
			"        int mid = (start + end) >> 1;",
			"        pointUpdate(2 * node, start, mid, updateIdx, val);",
			"        pointUpdate(2 * node + 1, mid + 1, end, updateIdx, val);",
			"        mergeNodes(tree[node], tree[2 * node], tree[2 * node + 1]);",
			"    }",
			"",
			"    T query(int node, int start, int end, int queryStartIdx, int queryEndIdx) {",
			"        // no overlap",
			"        if (queryEndIdx < start || queryStartIdx > end) {",
			"            return identity;",
			"        }",
			"        // total overlap",
			"        if (start >= queryStartIdx && end <= queryEndIdx) {",
			"            return tree[node];",
			"        }",
			"        // partial overlap",
			"        int mid = (start + end) >> 1;",
			"        T leftQuery = query(2 * node, start, mid, queryStartIdx, queryEndIdx);",
			"        T rightQuery = query(2 * node + 1, mid + 1, end, queryStartIdx, queryEndIdx);",
			"        T ans;",
			"        mergeNodes(ans, leftQuery, rightQuery);",
			"        return ans;",
			"    }",
			"",
			"  public:",
			"    vector<T> getTree() {",
			"        return tree;",
			"    }",
			"",
			"    SegmentTree(const vector<T> &input, function<T(T, T)> f, T id = 0)",
			"        : func(f), identity(id) {",
			"        n = (int)input.size();",
			"        tree.resize(4 * n, identity);",
			"        build(input, 1, 0, n - 1);",
			"    }",
			"",
			"    void pointUpdate(int idx, T val) {",
			"        pointUpdate(1, 0, n - 1, idx, val);",
			"    }",
			"",
			"    T rangeQuery(int startIdx, int endIdx) {",
			"        return query(1, 0, n - 1, startIdx, endIdx);",
			"    }",
			"};"
		],
		"description": "segment tree"
	},
	"Prime Sieve": {
		"prefix": "_primeSieve",
		"body": [
			"template <int N>",
			"struct Sieve {",
			"    array<int, N + 1> spf;",
			"",
			"    constexpr Sieve() {",
			"        spf.fill(0);",
			"        for (int i = 2; i * i <= N; i++) {",
			"            if (spf[i] == 0) {",
			"                for (int j = i * i; j <= N; j += i) {",
			"                    if (spf[j] == 0)",
			"                        spf[j] = i;",
			"                }",
			"            }",
			"        }",
			"        for (int i = 2; i <= N; i++) {",
			"            if (spf[i] == 0) {",
			"                spf[i] = i;",
			"            }",
			"        }",
			"    }",
			"",
			"    bool isPrime(int x) {",
			"        return spf[x] == x;",
			"    }",
			"",
			"    vector<int> primes() const {",
			"        vector<int> primes;",
			"        for (int i = 1; i <= N; i++) {",
			"            if (spf[i] == i) {",
			"                primes.push_back(i);",
			"            }",
			"        }",
			"        return primes;",
			"    }",
			"",
			"    vector<pair<int, int>> primeFactors(int x) const {",
			"        vector<pair<int, int>> factors;",
			"        while (x != 1) {",
			"            while (factors.empty() || factors.back().first != spf[x]) {",
			"                factors.emplace_back(spf[x], 0);",
			"            }",
			"            factors.back().second++;",
			"            x /= spf[x];",
			"        }",
			"        return factors;",
			"    }",
			"",
			"    vector<long long> divisors(long long x) {",
			"        assert(x > 0);",
			"        vector<long long> res;",
			"        for (long long i = 1; i * i <= x; i++) {",
			"            if (x % i == 0) {",
			"                res.push_back(i);",
			"                if (i != x / i) {",
			"                    res.push_back(x / i);",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"",
			"    int countOfDivisors(int x) const {",
			"        auto res = primeFactors(x);",
			"        int cnt = 1;",
			"        for (auto &it : res) {",
			"            cnt *= (it.second + 1);",
			"        }",
			"        return cnt;",
			"    }",
			"};",
			"",
			"constexpr int N = 1000000;",
			"Sieve<N> s;"
		],
		"description": "Prime Sieve"
	},
	"Distance between points": {
		"prefix": "_distance2points",
		"body": [
			"long long distance(long long x1, long long y1, long long x2, long long y2) {",
			"    long long distSquare = ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));",
			"    return distSquare;",
			"}"
		],
		"description": "Distance between points"
	},
	"multi-line comment": {
		"prefix": "_thinker",
		"body": [
			"/**",
			" * $0",
			"**/"
		],
		"description": "multi-line comment"
	},
	"GCD && LCM": {
		"prefix": "_gcd",
		"body": [
			"template <typename T> T gcd(T a, T b) {",
			"    if (a == 0)",
			"        return b;",
			"    return gcd(b % a, a);",
			"}",
			"",
			"template <typename T> T lcm(T a, T b) { return (a * b) / gcd(a, b); }"
		],
		"description": "GCD && LCM"
	},
	"modulo power": {
		"prefix": "_mpow",
		"body": [
			"long long mpow(long long a, long long b, long long m = mod) {",
			"    long long ans = 1;",
			"    while (b) {",
			"        if (b & 1LL) {",
			"            ans *= a;",
			"            ans %= m;",
			"        }",
			"        a *= a;",
			"        a %= m;",
			"        b = b >> 1;",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "modulo power"
	},
	"manacher algorithm for sub palindromes": {
		"prefix": "_manacher",
		"body": [
			"class Manacher {",
			"    vector<int> p;",
			"",
			"  public:",
			"    void constructArray(string s) {",
			"        int n = s.length();",
			"        p = vector<int>(n, 1);",
			"",
			"        for (int i = 1, L = 0, R = 0; i < n; i++) {",
			"            int radius = (i > R) ? 1 : min(p[L + R - i], R - i);",
			"            while (0 <= i - radius && i + radius < n && s[i - radius] == s[i + radius]) {",
			"                radius++;",
			"            }",
			"            p[i] = radius--;",
			"            if (i + radius > R) {",
			"                L = i - radius;",
			"                R = i + radius;",
			"            }",
			"        }",
			"    }",
			"",
			"    void build(string s) {",
			"        string mString;",
			"        for (char c : s) {",
			"            mString += '#';",
			"            mString += c;",
			"        }",
			"        mString += '#';",
			"        constructArray(mString);",
			"    }",
			"",
			"    int getLongestRadius(int at, bool isCenter) {",
			"        int position = 2 * at + 1;",
			"        if (!isCenter)",
			"            position++;",
			"        return p[position] / 2;",
			"    }",
			"",
			"    bool isPalindrome(int l, int r) {",
			"        int mid = (l + r) / 2;",
			"        int len = (r - l + 1);",
			"        if (l % 2 == r % 2) {",
			"            // odd manacher",
			"            return (getLongestRadius(mid, true) * 2 - 1) >= len;",
			"        } else {",
			"            // even manacher",
			"            return (getLongestRadius(mid, false) * 2) >= len;",
			"        }",
			"        return false;",
			"    }",
			"};"
		],
		"description": "manacher algorithm for sub palindromes"
	},
	"TreeNode": {
		"prefix": "_treeNode",
		"body": [
			"struct TreeNode {",
			"    int val;",
			"    TreeNode *left;",
			"    TreeNode *right;",
			"    TreeNode() : val(0), left(nullptr), right(nullptr) {}",
			"    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}",
			"    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}",
			"};"
		],
		"description": "TreeNode"
	},
	"Modular integer": {
		"prefix": "_mint",
		"body": [
			"template <int M> struct ModInt {",
			"    int val;",
			"",
			"    ModInt(long long x = 0) : val((x % M + M) % M) {}",
			"    inline ModInt pow(long long n) const {",
			"        ModInt ans = 1, x(*this);",
			"        while (n) {",
			"            if (n & 1)",
			"                ans *= x;",
			"            x *= x;",
			"            n /= 2;",
			"        }",
			"        return ans;",
			"    }",
			"    ModInt inverse() const { return pow(M - 2); }",
			"    inline ModInt inv() const { return pow(M - 2); }",
			"",
			"    inline friend ModInt pow(const ModInt &m, long long n) { return m.pow(n); }",
			"    inline friend ModInt inv(const ModInt &m) { return m.inv(); }",
			"",
			"    inline ModInt operator+() const {",
			"        ModInt m;",
			"        m.val = val;",
			"        return m;",
			"    }",
			"    inline ModInt operator-() const {",
			"        ModInt m;",
			"        m.val = M - val;",
			"        return m;",
			"    }",
			"    inline ModInt &operator+=(const ModInt &m) {",
			"        if ((val += m.val) >= M)",
			"            val -= M;",
			"        return *this;",
			"    }",
			"    inline ModInt &operator-=(const ModInt &m) {",
			"        if ((val -= m.val) < 0)",
			"            val += M;",
			"        return *this;",
			"    }",
			"    inline ModInt &operator*=(const ModInt &m) {",
			"        val = (long long)val * m.val % M;",
			"        return *this;",
			"    }",
			"    inline ModInt &operator/=(const ModInt &m) {",
			"        val = (long long)val * m.inv().val % M;",
			"        return *this;",
			"    }",
			"",
			"    inline friend ModInt operator+(const ModInt &lhs, const ModInt &rhs) {",
			"        return ModInt(lhs) += rhs;",
			"    }",
			"    inline friend ModInt operator-(const ModInt &lhs, const ModInt &rhs) {",
			"        return ModInt(lhs) -= rhs;",
			"    }",
			"    inline friend ModInt operator*(const ModInt &lhs, const ModInt &rhs) {",
			"        return ModInt(lhs) *= rhs;",
			"    }",
			"    inline friend ModInt operator/(const ModInt &lhs, const ModInt &rhs) {",
			"        return ModInt(lhs) /= rhs;",
			"    }",
			"    inline friend bool operator==(const ModInt &lhs, const ModInt &rhs) {",
			"        return lhs.val == rhs.val;",
			"    }",
			"    inline friend bool operator!=(const ModInt &lhs, const ModInt &rhs) {",
			"        return lhs.val != rhs.val;",
			"    }",
			"",
			"    inline ModInt &operator++() { return *this += 1; }",
			"    inline ModInt &operator--() { return *this -= 1; }",
			"    inline ModInt operator++(int) {",
			"        ModInt result(*this);",
			"        *this += 1;",
			"        return result;",
			"    }",
			"    inline ModInt operator--(int) {",
			"        ModInt result(*this);",
			"        *this -= 1;",
			"        return result;",
			"    }",
			"",
			"    template <typename T> inline explicit operator T() const { return T(val); }",
			"",
			"    friend std::ostream &operator<<(std::ostream &os, const ModInt &m) { return os << m.val; }",
			"    friend std::istream &operator>>(std::istream &is, ModInt &m) {",
			"        long long x;",
			"        is >> x;",
			"        m = x;",
			"        return is;",
			"    }",
			"};",
			"using mint = ModInt<mod>;"
		],
		"description": "Modular integer"
	},
	"policy based DS": {
		"prefix": "_pbds",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"/*",
			" * WARNING: functions as a set (doesn't allow duplicates);",
			"   insert pairs instead if duplicates are needed.",
			" * find_by_order(i) similar to a[i];",
			" * order_of_key(i) gives the number of items that are strictly smaller than i;",
			" */",
			"template <typename T>",
			"using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;"
		],
		"description": "policy based DS"
	},
	"Square root": {
		"prefix": "_squareRoot",
		"body": [
			"long long sqrt(long long num) {",
			"    assert(num >= 0);",
			"    long long s = 0;",
			"    long long e = 2e9 + 3;",
			"    long long root = -1;",
			"    while (s <= e) {",
			"        long long mid = (s + e) >> 1;",
			"        if (mid * mid <= num) {",
			"            root = mid;",
			"            s = mid + 1;",
			"        } else {",
			"            e = mid - 1;",
			"        }",
			"    }",
			"    assert(root != -1);",
			"    return root;",
			"}"
		],
		"description": "Square root"
	},
	"FenwickTree": {
		"prefix": "_fenwick",
		"body": [
			"template <typename T> class FenwickTree {",
			"  public:",
			"    int n;",
			"    vector<T> bit;",
			"    FenwickTree() : n(0) {}",
			"    FenwickTree(int n_) : n(n_) {",
			"        n = n_;",
			"        bit.assign(n + 1, 0);",
			"    }",
			"",
			"    int lsb(int x) { return (x & (-x)); }",
			"",
			"    void update(int i, T val) {",
			"        assert(i >= 0 && i < n);",
			"        i++;",
			"        while (i <= n) {",
			"            bit[i] += val;",
			"            i += lsb(i);",
			"        }",
			"    }",
			"",
			"    T query(int i) {",
			"        assert(i >= 0 && i < n);",
			"        i++;",
			"        T ans{};",
			"        while (i > 0) {",
			"            ans += bit[i];",
			"            i -= lsb(i);",
			"        }",
			"        return ans;",
			"    }",
			"",
			"    T query(int l, int r) { return query(r) - (l > 0 ? query(l - 1) : T()); }",
			"};"
		],
		"description": "FenwickTree"
	}
}
